// See the file "COPYING" in the main distribution directory for copyright.

#include <cppcodec/base64_default_rfc4648.hpp>
#include <iostream>
#include <fstream>
#include <sstream>
#include <iomanip>
#include <cstring>

extern "C" {
#include <unistd.h>
#include <openssl/x509.h>
#include <openssl/x509v3.h>
#include <openssl/asn1.h>
#include <openssl/opensslconf.h>
#include <openssl/err.h>
#include <openssl/sha.h>

#include "openssl_curves.c"
}

std::string toHex(const std::string& s, bool upper_case = false) {
	std::ostringstream ret;

	for (std::string::size_type i = 0; i < s.length(); ++i) {
		uint8_t p = s[i];
  	ret << std::hex << std::setfill('0') << std::setw(2) << (upper_case ? std::uppercase : std::nouppercase) << (int)p;
	}

	return ret.str();
}

template <typename T>
std::string sha256(T from) {
	unsigned char* out = SHA256(reinterpret_cast<const unsigned char*>(&from[0]), from.size(), nullptr);
	std::string outstr(reinterpret_cast<const char*>(out), 32);
	return outstr;
}

template <typename T>
std::string sha1(T from) {
	unsigned char* out = SHA1(reinterpret_cast<const unsigned char*>(&from[0]), from.size(), nullptr);
	std::string outstr(reinterpret_cast<const char*>(out), 20);
	return outstr;
}

int parseCert(X509* cert) {
	EVP_PKEY *pkey = X509_extract_key(cert);
	if ( ! pkey )
		return -3;

	if ( EVP_PKEY_base_id(pkey) == EVP_PKEY_EC ) {
		const EC_GROUP *group;
		if ( (group = EC_KEY_get0_group(EVP_PKEY_get0_EC_KEY(pkey))) == NULL )
			// I guess we could not parse this
			return -4;

		auto ctx = BN_CTX_new();
		auto ret = ec_curve_nid_from_params(group, ctx);
		BN_CTX_free(ctx);
		return ret;
	}
	return -5;
}

int main(int argc, char** argv) {
	if ( argc != 2 ) {
		std::cerr << "Expecting 1 argument: input file-name" << std::endl;
		exit(-1);
	}
	std::string infile = argv[1];
	std::ifstream in(infile);
	std::ofstream out;
	std::string line;
	auto pid = getpid();

	if ( !in ) {
		std::cerr << "Could not open source certificate file \"certificates\"" << std::endl;
		return -1;
	}

	while ( std::getline(in, line) ) {
		auto tab = line.find("\t");
		if ( tab == std::string::npos )
			tab = line.size();

		std::vector<uint8_t> decoded = base64::decode(line.data(), tab);
		const unsigned char* cert_char = reinterpret_cast<const unsigned char*>(&decoded[0]);
		std::string cert_str;
		cert_str.append(reinterpret_cast<const char*>(&decoded[0]), decoded.size());
		//std::string certhash = toHex(sha1(cert_str));
		//std::string certhash256 = toHex(sha256(cert_str));
		int ret = 0;
		X509* cert = d2i_X509(nullptr, &cert_char, decoded.size());
		if ( ! cert )
			ret = -2;
		else
			ret = parseCert(cert);

		if ( ret == 0 || ret == -1 || ret == -4 ) {
			// 0 is the actual interesting ones - the other 2 are kind of just in case...
			if ( ! out.is_open() ) {
				out.open(infile + ".cve-2020-0601." + std::to_string(pid) + ".out");
				if ( ! out.is_open() ) {
					std::cerr << "cannot open output file" << std::endl;
					exit(-1);
				}
			}
			out << ret << "\t" << line;
		}
		std::cout << ret << std::endl;
		X509_free(cert);
	}

	std::cerr << "Done" << std::endl;
	in.close();
	return 0;
}

